{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Notes","title":"Home"},{"location":"#welcome-to-my-notes","text":"","title":"Welcome to My Notes"},{"location":"about/","text":"About this site Lorem ipsum dolor sit amet, adipisicing quis sunt ad excepteur et labore dolore duis eu aute ipsum non proident anim. Cupidatat nostrud consectetur voluptate es se voluptate enim ex reprehenderit commodo sint quis amet irure eiusmod excepteu r incididunt dolor laborum. Aute occaecat dolore qui tempor irure id velit sunt velit cillum esse. Occaecat amet cupidatat ad et ea labore irure pariatur non nostrud officia est m agna commodo enim mollit cillum nostrud. Laboris ea est cupidatat laboris mollit incididunt culpa. Duis aliquip ex aute deserunt ad ullamco sunt elit tempor do culpa excepteur ea laborum. Laborum proident eiusmod dolore qui quis commodo Lor em irure ea ullamco Lorem duis tempor sint. Occaecat dolor consequat est aliquip aute cupidatat. Non dolore veniam laboris officia culpa aliquip est tempor veni am. Id sint sunt laboris commodo deserunt. Duis ut irure excepteur exercitation dolore nisi. Proident officia ad ut nostrud elit consequat quis elit quis et occaecat aliqua mollit nulla proident aliquip fugiat voluptate consectetur. Sit deserunt excepte ur dolore ipsum elit. Deserunt officia laboris minim non consequat culpa nisi co nsectetur duis non aute magna duis nostrud nulla consequat labore labore do. Lab ore sunt aute anim amet magna laborum ad amet laborum sint nisi ex excepteur con sequat Lorem commodo nostrud. Id aute culpa incididunt. Mollit proident consequat ea officia cupidatat incidid unt. Sint deserunt tempor minim labore velit exercitation quis ut labore proiden t dolor sunt. Nostrud nulla tempor veniam ut exercitation esse. Anim qui laboris ea in enim reprehenderit cillum adipisicing est nisi ut. Id anim est voluptate sunt est non exercitation consequat aute deserunt. Occaecat aliqua adipisicing i d excepteur nostrud incididunt amet commodo anim consectetur reprehenderit sit. Anim duis voluptate excepteur eiusmod reprehenderit dolor Lorem exercitation sit qui amet minim aliqua est Lorem consequat do ea. Consectetur voluptate id volup tate aliquip officia fugiat pariatur et anim. Ut deserunt fugiat ipsum. Est nost rud labore nisi veniam ad. Pariatur ex eiusmod nisi deserunt velit excepteur sit quis culpa id consectetur cillum. Nostrud eiusmod sit eiusmod do eu laboris nis i cupidatat quis veniam sit duis. Ipsum reprehenderit excepteur qui in culpa mollit. Et adipisicing cupidatat esse culpa sunt enim aute veniam quis nostrud velit. Lorem enim enim consequat. Amet eu excepteur aliqua minim non eu ea veniam aliqua laborum sint ullamco et repre henderit. Est irure ex adipisicing nisi minim elit ut laborum velit elit quis ve lit ad magna anim nisi. Commodo laboris laboris labore culpa magna ex in. Exerci tation fugiat nisi est velit est ipsum veniam ea occaecat dolore id tempor duis. Nostrud occaecat magna deserunt sunt esse Lorem adipisicing amet enim nostrud. Nulla aliqua cupidatat consequat cillum id incididunt aute laboris labore incidi dunt et quis. Tempor deserunt enim in occaecat proident laboris non. Occaecat do lore qui ullamco irure. Exercitation nostrud qui nostrud laborum velit ullamco e a amet excepteur laborum commodo quis culpa aliqua dolore proident nisi sit. Inc ididunt sunt laborum labore est cupidatat in ad incididunt ut Lorem et culpa cil lum minim enim laborum irure ad mollit. Elit elit excepteur consequat nulla nost rud consequat est nostrud duis eu in cillum magna reprehenderit consequat fugiat culpa velit labore. Ut laboris deserunt tempor occaecat anim in qui amet. Exercitation sint laborum cupidatat occaecat sit consequat non eu commodo pariat ur voluptate sint ad. Fugiat eu reprehenderit amet occaecat exercitation reprehe nderit cillum occaecat sunt est anim. Aute quis duis laborum minim esse incididu nt non amet irure. Dolore amet nostrud qui commodo irure nostrud laborum proiden t exercitation sunt ullamco qui commodo. Ipsum sunt culpa ex ullamco dolor aliqu a. Aliqua id veniam magna sint aliquip ad ad est culpa adipisicing ad minim ad sint ut. Irure ad sint aliquip qui ex mollit est pariatur sunt tempor. Sint culpa co nsectetur ea excepteur aliqua dolor. Quis reprehenderit elit dolore dolore fugia t veniam. Aute sit eu mollit eiusmod dolor qui ipsum in. Cillum exercitation ut fugiat Lorem dolore esse dolor ad enim. Aliqua non irure aliquip velit aliqua ad aute labore sit eiusmod. Ut mollit incididunt est quis Lorem eiusmod mollit ex Lorem est. Magna ad ad cillum amet eu. Exercitation do sunt dolor exercitation reprehenderit incididunt excepteur et ex reprehenderit. Reprehenderit velit est in duis ex qui ad laboris ex qui aliqua fugiat ut. Ex laborum ea dolore esse anim laboris dolore dolore dolor esse elit dolor.","title":"About this site"},{"location":"about/#about-this-site","text":"Lorem ipsum dolor sit amet, adipisicing quis sunt ad excepteur et labore dolore duis eu aute ipsum non proident anim. Cupidatat nostrud consectetur voluptate es se voluptate enim ex reprehenderit commodo sint quis amet irure eiusmod excepteu r incididunt dolor laborum. Aute occaecat dolore qui tempor irure id velit sunt velit cillum esse. Occaecat amet cupidatat ad et ea labore irure pariatur non nostrud officia est m agna commodo enim mollit cillum nostrud. Laboris ea est cupidatat laboris mollit incididunt culpa. Duis aliquip ex aute deserunt ad ullamco sunt elit tempor do culpa excepteur ea laborum. Laborum proident eiusmod dolore qui quis commodo Lor em irure ea ullamco Lorem duis tempor sint. Occaecat dolor consequat est aliquip aute cupidatat. Non dolore veniam laboris officia culpa aliquip est tempor veni am. Id sint sunt laboris commodo deserunt. Duis ut irure excepteur exercitation dolore nisi. Proident officia ad ut nostrud elit consequat quis elit quis et occaecat aliqua mollit nulla proident aliquip fugiat voluptate consectetur. Sit deserunt excepte ur dolore ipsum elit. Deserunt officia laboris minim non consequat culpa nisi co nsectetur duis non aute magna duis nostrud nulla consequat labore labore do. Lab ore sunt aute anim amet magna laborum ad amet laborum sint nisi ex excepteur con sequat Lorem commodo nostrud. Id aute culpa incididunt. Mollit proident consequat ea officia cupidatat incidid unt. Sint deserunt tempor minim labore velit exercitation quis ut labore proiden t dolor sunt. Nostrud nulla tempor veniam ut exercitation esse. Anim qui laboris ea in enim reprehenderit cillum adipisicing est nisi ut. Id anim est voluptate sunt est non exercitation consequat aute deserunt. Occaecat aliqua adipisicing i d excepteur nostrud incididunt amet commodo anim consectetur reprehenderit sit. Anim duis voluptate excepteur eiusmod reprehenderit dolor Lorem exercitation sit qui amet minim aliqua est Lorem consequat do ea. Consectetur voluptate id volup tate aliquip officia fugiat pariatur et anim. Ut deserunt fugiat ipsum. Est nost rud labore nisi veniam ad. Pariatur ex eiusmod nisi deserunt velit excepteur sit quis culpa id consectetur cillum. Nostrud eiusmod sit eiusmod do eu laboris nis i cupidatat quis veniam sit duis. Ipsum reprehenderit excepteur qui in culpa mollit. Et adipisicing cupidatat esse culpa sunt enim aute veniam quis nostrud velit. Lorem enim enim consequat. Amet eu excepteur aliqua minim non eu ea veniam aliqua laborum sint ullamco et repre henderit. Est irure ex adipisicing nisi minim elit ut laborum velit elit quis ve lit ad magna anim nisi. Commodo laboris laboris labore culpa magna ex in. Exerci tation fugiat nisi est velit est ipsum veniam ea occaecat dolore id tempor duis. Nostrud occaecat magna deserunt sunt esse Lorem adipisicing amet enim nostrud. Nulla aliqua cupidatat consequat cillum id incididunt aute laboris labore incidi dunt et quis. Tempor deserunt enim in occaecat proident laboris non. Occaecat do lore qui ullamco irure. Exercitation nostrud qui nostrud laborum velit ullamco e a amet excepteur laborum commodo quis culpa aliqua dolore proident nisi sit. Inc ididunt sunt laborum labore est cupidatat in ad incididunt ut Lorem et culpa cil lum minim enim laborum irure ad mollit. Elit elit excepteur consequat nulla nost rud consequat est nostrud duis eu in cillum magna reprehenderit consequat fugiat culpa velit labore. Ut laboris deserunt tempor occaecat anim in qui amet. Exercitation sint laborum cupidatat occaecat sit consequat non eu commodo pariat ur voluptate sint ad. Fugiat eu reprehenderit amet occaecat exercitation reprehe nderit cillum occaecat sunt est anim. Aute quis duis laborum minim esse incididu nt non amet irure. Dolore amet nostrud qui commodo irure nostrud laborum proiden t exercitation sunt ullamco qui commodo. Ipsum sunt culpa ex ullamco dolor aliqu a. Aliqua id veniam magna sint aliquip ad ad est culpa adipisicing ad minim ad sint ut. Irure ad sint aliquip qui ex mollit est pariatur sunt tempor. Sint culpa co nsectetur ea excepteur aliqua dolor. Quis reprehenderit elit dolore dolore fugia t veniam. Aute sit eu mollit eiusmod dolor qui ipsum in. Cillum exercitation ut fugiat Lorem dolore esse dolor ad enim. Aliqua non irure aliquip velit aliqua ad aute labore sit eiusmod. Ut mollit incididunt est quis Lorem eiusmod mollit ex Lorem est. Magna ad ad cillum amet eu. Exercitation do sunt dolor exercitation reprehenderit incididunt excepteur et ex reprehenderit. Reprehenderit velit est in duis ex qui ad laboris ex qui aliqua fugiat ut. Ex laborum ea dolore esse anim laboris dolore dolore dolor esse elit dolor.","title":"About this site"},{"location":"angular/","text":"Learning Angular Displaying data from the component Interpolation <span>{{ title }}</span> Property Binding <span [innerText]=\"title\"></span> Notice that we bind to the Document Object Model (DOM) property of an element, not an HTML attribute, as it looks at first sight. The property inside square brackets is called the target property and is the property of the DOM element into which we want to bind. The variable on the right is called the template expression and corresponds to the public title property of the component. If the property is not public, the template will not be able to use it. To better understand how the Angular templating mechanism works, we need to first understand how Angular interacts with attributes and properties. It defines attributes in HTML to initialize a DOM property, and then it uses data binding to interact with the property directly Applying styles to the template The Angular framework provides two types of property binding to set both of them dynamically, class binding and style binding . We can apply a single class to an HTML element using the following syntax. <p [class.star]=\"isLiked\"></p> The star class will be added to the paragraph element when the isLiked expression is true. Otherwise, it will be removed from the element. If we want to apply multiple classes simultaneously, we can use the following syntax: <p [class]=\"currentClasses\"></p> Getting data from the template (event binding) An event binding listens for DOM events that occur on the target HTML element and responds to those events by calling corresponding methods in the component. <button (click)=\"onClick()\">Click me</button> It supports native DOM events that can be found at https://developer.mozilla.org/en-US/docs/Web/Events . The variable on the right is called the template statement and corresponds to the onClick public method of the component. Component methods must be public for the template to be able to call them. Communicating with other components Angular components expose a public API that allows them to communicate with other components. This API encompasses input properties , which we use to feed the component with data. It also exposes output properties we can bind event listeners to, thereby getting timely information about changes in the state of the component. Directives There are three types of directives: Components are directives with an associated template. Structural directives add or remove elements from the DOM. Attribute directives modify the appearance or define a custom behavior of a DOM element. Transforming elements using directives The Angular framework includes a set of ready-made structural directives that we can start using straight away: ngIf adds or removes a portion of the DOM tree based on an expression. ngFor iterates through a list of items and binds each item to a template. ngSwitch switches between templates within a specific set and displays each one depending on a condition Structure an Angular App How to create an Angular application that is correctly structured to enforce separation of concerns using modules and services An Angular module is a TypeScript class marked with the @NgModule decorator, which defines the following properties: declarations : The components, directives, and pipes that are registered with the module. imports : Other modules that contain declarations to be used by this module. The Angular CLI defines CommonModule automatically for us in this property. It is a module that is always used in Angular applications because it contains all the built-in directives and pipes that we usually would like to use. exports : Angular artifacts that are defined in declarations and are available for other modules to use. This is the public API of the module. It defines what is publicly accessible or not. Everything else that's not explicitly exported would be considered private or internal to the module. providers : Services that are provided from the module and are accessible from any module of the application. We'll learn more about providers in the How dependency injection works in Angular section. bootstrap : The main component of the application that will be rendered when the application starts up. This property is set only once in the main application module, AppModule, and is usually AppComponent. Typically, you should not change it unless there is a particular reason to do so.Important NoteThe main application module, AppModule, does not need to import CommonModule. Instead, it imports BrowserModule, which is used to run Angular applications in a browser platform that exports CommonModule by itself. When creating a new Angular application, the first step is to define the different features our application needs. We should keep in mind that each one should make sense on its own in isolation from the others. Once we've defined the set of features required, we will create a module for each one. Each module will then be filled with the components, directives, pipes, and services that shape the feature it represents. Always remember the principles of encapsulation and reusability when defining your feature set. The second step is to start creating components that will be used to visualize the features on the screen. Dependency Injection Angular components are responsible for the presentation logic and should not be concerned with how to get data, either from a static list or a remote endpoint. They only need to display it in the template. Thus, they delegate business logic to services to handle this type of task. An Angular service, by default, is not registered with a specific module like components, directives, and pipes are. Instead, it is registered with an injector \u2013 the root injector of the Angular application \u2013 as defined in the providedIn option import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } } Promises Promises introduce a new way of envisioning asynchronous data management by conforming to a neater and more solid interface. Different asynchronous operations can be chained at the same level and even be split and returned from other functions Limitations of Promises They cannot be canceled. They are immediately executed. They are one-time operations only; there is no easy way to retry them. They respond with only one value. Observables An observable is an object that maintains a list of dependents, called observers, and informs them about state and data changes by emitting events asynchronously. To do so, the observable implements all of the machinery that it needs to produce and emit such events. It can be fired and canceled any time, regardless of whether it has emitted the expected data already Observables return a stream of events, and our subscribers receive prompt notification of those events so that they can act accordingly. They do not perform an asynchronous operation and die (although we can configure them to do so), but start a stream of continuous events on which we can subscribe. That's not all, however. This stream can be a combination of many operations before they hit observers subscribed to it. Just as we can manipulate arrays with methods such as map or filter to transform them, we can do the same with the stream of events that are emitted by observables. This is known as reactive functional programming, and Angular makes the most of this paradigm to handle asynchronous information.","title":"Angular"},{"location":"angular/#learning-angular","text":"","title":"Learning Angular"},{"location":"angular/#displaying-data-from-the-component","text":"","title":"Displaying data from the component"},{"location":"angular/#interpolation","text":"<span>{{ title }}</span>","title":"Interpolation"},{"location":"angular/#property-binding","text":"<span [innerText]=\"title\"></span> Notice that we bind to the Document Object Model (DOM) property of an element, not an HTML attribute, as it looks at first sight. The property inside square brackets is called the target property and is the property of the DOM element into which we want to bind. The variable on the right is called the template expression and corresponds to the public title property of the component. If the property is not public, the template will not be able to use it. To better understand how the Angular templating mechanism works, we need to first understand how Angular interacts with attributes and properties. It defines attributes in HTML to initialize a DOM property, and then it uses data binding to interact with the property directly","title":"Property Binding"},{"location":"angular/#applying-styles-to-the-template","text":"The Angular framework provides two types of property binding to set both of them dynamically, class binding and style binding . We can apply a single class to an HTML element using the following syntax. <p [class.star]=\"isLiked\"></p> The star class will be added to the paragraph element when the isLiked expression is true. Otherwise, it will be removed from the element. If we want to apply multiple classes simultaneously, we can use the following syntax: <p [class]=\"currentClasses\"></p>","title":"Applying styles to the template"},{"location":"angular/#getting-data-from-the-template-event-binding","text":"An event binding listens for DOM events that occur on the target HTML element and responds to those events by calling corresponding methods in the component. <button (click)=\"onClick()\">Click me</button> It supports native DOM events that can be found at https://developer.mozilla.org/en-US/docs/Web/Events . The variable on the right is called the template statement and corresponds to the onClick public method of the component. Component methods must be public for the template to be able to call them.","title":"Getting data from the template (event binding)"},{"location":"angular/#communicating-with-other-components","text":"Angular components expose a public API that allows them to communicate with other components. This API encompasses input properties , which we use to feed the component with data. It also exposes output properties we can bind event listeners to, thereby getting timely information about changes in the state of the component.","title":"Communicating with other components"},{"location":"angular/#directives","text":"There are three types of directives: Components are directives with an associated template. Structural directives add or remove elements from the DOM. Attribute directives modify the appearance or define a custom behavior of a DOM element.","title":"Directives"},{"location":"angular/#transforming-elements-using-directives","text":"The Angular framework includes a set of ready-made structural directives that we can start using straight away: ngIf adds or removes a portion of the DOM tree based on an expression. ngFor iterates through a list of items and binds each item to a template. ngSwitch switches between templates within a specific set and displays each one depending on a condition","title":"Transforming elements using directives"},{"location":"angular/#structure-an-angular-app","text":"How to create an Angular application that is correctly structured to enforce separation of concerns using modules and services An Angular module is a TypeScript class marked with the @NgModule decorator, which defines the following properties: declarations : The components, directives, and pipes that are registered with the module. imports : Other modules that contain declarations to be used by this module. The Angular CLI defines CommonModule automatically for us in this property. It is a module that is always used in Angular applications because it contains all the built-in directives and pipes that we usually would like to use. exports : Angular artifacts that are defined in declarations and are available for other modules to use. This is the public API of the module. It defines what is publicly accessible or not. Everything else that's not explicitly exported would be considered private or internal to the module. providers : Services that are provided from the module and are accessible from any module of the application. We'll learn more about providers in the How dependency injection works in Angular section. bootstrap : The main component of the application that will be rendered when the application starts up. This property is set only once in the main application module, AppModule, and is usually AppComponent. Typically, you should not change it unless there is a particular reason to do so.Important NoteThe main application module, AppModule, does not need to import CommonModule. Instead, it imports BrowserModule, which is used to run Angular applications in a browser platform that exports CommonModule by itself. When creating a new Angular application, the first step is to define the different features our application needs. We should keep in mind that each one should make sense on its own in isolation from the others. Once we've defined the set of features required, we will create a module for each one. Each module will then be filled with the components, directives, pipes, and services that shape the feature it represents. Always remember the principles of encapsulation and reusability when defining your feature set. The second step is to start creating components that will be used to visualize the features on the screen.","title":"Structure an Angular App"},{"location":"angular/#dependency-injection","text":"Angular components are responsible for the presentation logic and should not be concerned with how to get data, either from a static list or a remote endpoint. They only need to display it in the template. Thus, they delegate business logic to services to handle this type of task. An Angular service, by default, is not registered with a specific module like components, directives, and pipes are. Instead, it is registered with an injector \u2013 the root injector of the Angular application \u2013 as defined in the providedIn option import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } }","title":"Dependency Injection"},{"location":"angular/#promises","text":"Promises introduce a new way of envisioning asynchronous data management by conforming to a neater and more solid interface. Different asynchronous operations can be chained at the same level and even be split and returned from other functions","title":"Promises"},{"location":"angular/#limitations-of-promises","text":"They cannot be canceled. They are immediately executed. They are one-time operations only; there is no easy way to retry them. They respond with only one value.","title":"Limitations of Promises"},{"location":"angular/#observables","text":"An observable is an object that maintains a list of dependents, called observers, and informs them about state and data changes by emitting events asynchronously. To do so, the observable implements all of the machinery that it needs to produce and emit such events. It can be fired and canceled any time, regardless of whether it has emitted the expected data already Observables return a stream of events, and our subscribers receive prompt notification of those events so that they can act accordingly. They do not perform an asynchronous operation and die (although we can configure them to do so), but start a stream of continuous events on which we can subscribe. That's not all, however. This stream can be a combination of many operations before they hit observers subscribed to it. Just as we can manipulate arrays with methods such as map or filter to transform them, we can do the same with the stream of events that are emitted by observables. This is known as reactive functional programming, and Angular makes the most of this paradigm to handle asynchronous information.","title":"Observables"},{"location":"aws-data-pipeline/","text":"AWS Data Pipeline","title":"AWS Data Pipeline"},{"location":"aws-data-pipeline/#aws-data-pipeline","text":"","title":"AWS Data Pipeline"},{"location":"aws-glue/","text":"AWS Glue Fully managed ETL, serverless architecture and tool AWS Glue Crawler creates metadata in the data catalog Generates Scala or Phyton code for Apache Spark using an ETL firendly UI Jobs can be scheduled, run on demand, triggered from an event Can specify job dependencies or run them in parallel Cost Model Pay an hourly rate, billed by the second, for crawlers (discovering data) and ETL Jobs (processing and loading data) For data catalog, pay a simple monthly fee for storing and accessing the metadata Platform Serverless, AWS Glue offers a graphical interface for authoring Glue jobs to process your data. After you define the flow of your data sources, transformations and targets in the visual interface, AWS Glue studio will generate Apache Spark code on your behalf Integration Model AWS Glue is Integrated across a wide range of AWS services, so it natively supports data stored in Amazon Aurora, Amazon RDS engines, Amazon Redshift, Amazon S3, as well as common database engines. Kafka Integration Can be integrated via S3 interface Benefits Serverless - you pay for resources used while AWS Glue is running. Crawler - detects and infers schemas from data sources with very little configuring. Auto code generation in Python or Scala Inhibitors Languages are limited to Python and Scala Jobs must be edited when schemas are updated. Still relatively a young product, no third-party out-of-box connectors Setup Diagram shows how to setup a AWS Glue Crawler Diagram shows how to setup a AWS Glue Job","title":"Glue"},{"location":"aws-glue/#aws-glue","text":"Fully managed ETL, serverless architecture and tool AWS Glue Crawler creates metadata in the data catalog Generates Scala or Phyton code for Apache Spark using an ETL firendly UI Jobs can be scheduled, run on demand, triggered from an event Can specify job dependencies or run them in parallel","title":"AWS Glue"},{"location":"aws-glue/#cost-model","text":"Pay an hourly rate, billed by the second, for crawlers (discovering data) and ETL Jobs (processing and loading data) For data catalog, pay a simple monthly fee for storing and accessing the metadata","title":"Cost Model"},{"location":"aws-glue/#platform","text":"Serverless, AWS Glue offers a graphical interface for authoring Glue jobs to process your data. After you define the flow of your data sources, transformations and targets in the visual interface, AWS Glue studio will generate Apache Spark code on your behalf","title":"Platform"},{"location":"aws-glue/#integration-model","text":"AWS Glue is Integrated across a wide range of AWS services, so it natively supports data stored in Amazon Aurora, Amazon RDS engines, Amazon Redshift, Amazon S3, as well as common database engines.","title":"Integration Model"},{"location":"aws-glue/#kafka-integration","text":"Can be integrated via S3 interface","title":"Kafka Integration"},{"location":"aws-glue/#benefits","text":"Serverless - you pay for resources used while AWS Glue is running. Crawler - detects and infers schemas from data sources with very little configuring. Auto code generation in Python or Scala","title":"Benefits"},{"location":"aws-glue/#inhibitors","text":"Languages are limited to Python and Scala Jobs must be edited when schemas are updated. Still relatively a young product, no third-party out-of-box connectors","title":"Inhibitors"},{"location":"aws-glue/#setup","text":"","title":"Setup"},{"location":"aws-glue/#diagram-shows-how-to-setup-a-aws-glue-crawler","text":"","title":"Diagram shows how to setup a AWS Glue Crawler"},{"location":"aws-glue/#diagram-shows-how-to-setup-a-aws-glue-job","text":"","title":"Diagram shows how to setup a AWS Glue Job"},{"location":"azure-vm/","text":"Azure Virtual Machines","title":"Azure VMs"},{"location":"azure-vm/#azure-virtual-machines","text":"","title":"Azure Virtual Machines"},{"location":"streams/","text":"Process Unbounded and Bounded Data Any kind of data is produced as a stream of events. Credit card transactions, sensor measurements, machine logs, or user interactions on a website or mobile application, all of these data are generated as a stream. Data can be processed as unbounded or bounded streams. Unbounded streams Unbounded streams have a start but no defined end. They do not terminate and provide data as it is generated. Unbounded streams must be continuously processed, i.e., events must be promptly handled after they have been ingested. It is not possible to wait for all input data to arrive because the input is unbounded and will not be complete at any point in time. Processing unbounded data often requires that events are ingested in a specific order, such as the order in which events occurred, to be able to reason about result completeness. Bounded streams Bounded streams can be processed by ingesting all data before performing any computations. Ordered ingestion is not required to process bounded streams because a bounded data set can always be sorted. Processing of bounded streams is also known as batch processing.","title":"Streams"},{"location":"streams/#process-unbounded-and-bounded-data","text":"Any kind of data is produced as a stream of events. Credit card transactions, sensor measurements, machine logs, or user interactions on a website or mobile application, all of these data are generated as a stream. Data can be processed as unbounded or bounded streams.","title":"Process Unbounded and Bounded Data"},{"location":"streams/#unbounded-streams","text":"Unbounded streams have a start but no defined end. They do not terminate and provide data as it is generated. Unbounded streams must be continuously processed, i.e., events must be promptly handled after they have been ingested. It is not possible to wait for all input data to arrive because the input is unbounded and will not be complete at any point in time. Processing unbounded data often requires that events are ingested in a specific order, such as the order in which events occurred, to be able to reason about result completeness.","title":"Unbounded streams"},{"location":"streams/#bounded-streams","text":"Bounded streams can be processed by ingesting all data before performing any computations. Ordered ingestion is not required to process bounded streams because a bounded data set can always be sorted. Processing of bounded streams is also known as batch processing.","title":"Bounded streams"}]}