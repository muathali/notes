{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Notes","title":"Home"},{"location":"#welcome-to-my-notes","text":"","title":"Welcome to My Notes"},{"location":"aws-data-pipeline/","text":"AWS Data Pipeline","title":"AWS Data Pipeline"},{"location":"aws-data-pipeline/#aws-data-pipeline","text":"","title":"AWS Data Pipeline"},{"location":"aws-glue/","text":"AWS Glue Fully managed ETL, serverless architecture and tool AWS Glue Crawler creates metadata in the data catalog Generates Scala or Phyton code for Apache Spark using an ETL firendly UI Jobs can be scheduled, run on demand, triggered from an event Can specify job dependencies or run them in parallel Cost Model Pay an hourly rate, billed by the second, for crawlers (discovering data) and ETL Jobs (processing and loading data) For data catalog, pay a simple monthly fee for storing and accessing the metadata Platform Serverless, AWS Glue offers a graphical interface for authoring Glue jobs to process your data. After you define the flow of your data sources, transformations and targets in the visual interface, AWS Glue studio will generate Apache Spark code on your behalf Integration Model AWS Glue is Integrated across a wide range of AWS services, so it natively supports data stored in Amazon Aurora, Amazon RDS engines, Amazon Redshift, Amazon S3, as well as common database engines. Kafka Integration Can be integrated via S3 interface Benefits Serverless - you pay for resources used while AWS Glue is running. Crawler - detects and infers schemas from data sources with very little configuring. Auto code generation in Python or Scala Inhibitors Languages are limited to Python and Scala Jobs must be edited when schemas are updated. Still relatively a young product, no third-party out-of-box connectors Setup Diagram shows how to setup a AWS Glue Crawler Diagram shows how to setup a AWS Glue Job","title":"Glue"},{"location":"aws-glue/#aws-glue","text":"Fully managed ETL, serverless architecture and tool AWS Glue Crawler creates metadata in the data catalog Generates Scala or Phyton code for Apache Spark using an ETL firendly UI Jobs can be scheduled, run on demand, triggered from an event Can specify job dependencies or run them in parallel","title":"AWS Glue"},{"location":"aws-glue/#cost-model","text":"Pay an hourly rate, billed by the second, for crawlers (discovering data) and ETL Jobs (processing and loading data) For data catalog, pay a simple monthly fee for storing and accessing the metadata","title":"Cost Model"},{"location":"aws-glue/#platform","text":"Serverless, AWS Glue offers a graphical interface for authoring Glue jobs to process your data. After you define the flow of your data sources, transformations and targets in the visual interface, AWS Glue studio will generate Apache Spark code on your behalf","title":"Platform"},{"location":"aws-glue/#integration-model","text":"AWS Glue is Integrated across a wide range of AWS services, so it natively supports data stored in Amazon Aurora, Amazon RDS engines, Amazon Redshift, Amazon S3, as well as common database engines.","title":"Integration Model"},{"location":"aws-glue/#kafka-integration","text":"Can be integrated via S3 interface","title":"Kafka Integration"},{"location":"aws-glue/#benefits","text":"Serverless - you pay for resources used while AWS Glue is running. Crawler - detects and infers schemas from data sources with very little configuring. Auto code generation in Python or Scala","title":"Benefits"},{"location":"aws-glue/#inhibitors","text":"Languages are limited to Python and Scala Jobs must be edited when schemas are updated. Still relatively a young product, no third-party out-of-box connectors","title":"Inhibitors"},{"location":"aws-glue/#setup","text":"","title":"Setup"},{"location":"aws-glue/#diagram-shows-how-to-setup-a-aws-glue-crawler","text":"","title":"Diagram shows how to setup a AWS Glue Crawler"},{"location":"aws-glue/#diagram-shows-how-to-setup-a-aws-glue-job","text":"","title":"Diagram shows how to setup a AWS Glue Job"},{"location":"azure-vm/","text":"Azure Virtual Machines","title":"Azure VMs"},{"location":"azure-vm/#azure-virtual-machines","text":"","title":"Azure Virtual Machines"},{"location":"docker/","text":"Docker Command Description docker run Runs an image in docker docker ps Shows running containers docker ps -a Shows all including previously stopped containers docker stop Stops container docker rm Removes a container docker images List images docker rmi Removes image docker pull Pulls image from registry docker exec Execute a command on a running container docker run -it [container] bash Run container in interactive mode docker build -t [image name] -f dockerfile . Builds a docker image By default docker does not listen to standard input Use the -I parameter to map the docker standard input to host standard input for interactive mode Use the -t to attach to the terminal Every docker container is assigned an internal ip address accessible from the docker host You can also access using the docker host ip address, but need to map a free port on the host to the application port on the container","title":"Docker"},{"location":"docker/#docker","text":"Command Description docker run Runs an image in docker docker ps Shows running containers docker ps -a Shows all including previously stopped containers docker stop Stops container docker rm Removes a container docker images List images docker rmi Removes image docker pull Pulls image from registry docker exec Execute a command on a running container docker run -it [container] bash Run container in interactive mode docker build -t [image name] -f dockerfile . Builds a docker image By default docker does not listen to standard input Use the -I parameter to map the docker standard input to host standard input for interactive mode Use the -t to attach to the terminal Every docker container is assigned an internal ip address accessible from the docker host You can also access using the docker host ip address, but need to map a free port on the host to the application port on the container","title":"Docker"},{"location":"mac-os/","text":"Mac OS Key bindings Create DefaultKeyBinding.dict in ~/Library/Key Bindings with the following contents { \"\\UF729\" = moveToBeginningOfParagraph:; // home \"\\UF72B\" = moveToEndOfParagraph:; // end \"$\\UF729\" = moveToBeginningOfParagraphAndModifySelection:; // shift-home \"$\\UF72B\" = moveToEndOfParagraphAndModifySelection:; // shift-end \"^\\UF729\" = moveToBeginningOfDocument:; // ctrl-home \"^\\UF72B\" = moveToEndOfDocument:; // ctrl-end \"^$\\UF729\" = moveToBeginningOfDocumentAndModifySelection:; // ctrl-shift-home \"^$\\UF72B\" = moveToEndOfDocumentAndModifySelection:; // ctrl-shift-end }","title":"Mac OS"},{"location":"mac-os/#mac-os","text":"","title":"Mac OS"},{"location":"mac-os/#key-bindings","text":"Create DefaultKeyBinding.dict in ~/Library/Key Bindings with the following contents { \"\\UF729\" = moveToBeginningOfParagraph:; // home \"\\UF72B\" = moveToEndOfParagraph:; // end \"$\\UF729\" = moveToBeginningOfParagraphAndModifySelection:; // shift-home \"$\\UF72B\" = moveToEndOfParagraphAndModifySelection:; // shift-end \"^\\UF729\" = moveToBeginningOfDocument:; // ctrl-home \"^\\UF72B\" = moveToEndOfDocument:; // ctrl-end \"^$\\UF729\" = moveToBeginningOfDocumentAndModifySelection:; // ctrl-shift-home \"^$\\UF72B\" = moveToEndOfDocumentAndModifySelection:; // ctrl-shift-end }","title":"Key bindings"},{"location":"oauth2/","text":"","title":"OAuth2"},{"location":"streams/","text":"Process Unbounded and Bounded Data Any kind of data is produced as a stream of events. Credit card transactions, sensor measurements, machine logs, or user interactions on a website or mobile application, all of these data are generated as a stream. Data can be processed as unbounded or bounded streams. Unbounded streams Unbounded streams have a start but no defined end. They do not terminate and provide data as it is generated. Unbounded streams must be continuously processed, i.e., events must be promptly handled after they have been ingested. It is not possible to wait for all input data to arrive because the input is unbounded and will not be complete at any point in time. Processing unbounded data often requires that events are ingested in a specific order, such as the order in which events occurred, to be able to reason about result completeness. Bounded streams Bounded streams can be processed by ingesting all data before performing any computations. Ordered ingestion is not required to process bounded streams because a bounded data set can always be sorted. Processing of bounded streams is also known as batch processing. ksqlDB create stream orders_stream (orderId int, product VARCHAR) WITH (KAFKA_TOPIC='streaming.orders.input', VALUE_FORMAT='JSON'); select * from orders_stream emit changes; SET 'auto.offset.reset'='earliest';","title":"Streams"},{"location":"streams/#process-unbounded-and-bounded-data","text":"Any kind of data is produced as a stream of events. Credit card transactions, sensor measurements, machine logs, or user interactions on a website or mobile application, all of these data are generated as a stream. Data can be processed as unbounded or bounded streams.","title":"Process Unbounded and Bounded Data"},{"location":"streams/#unbounded-streams","text":"Unbounded streams have a start but no defined end. They do not terminate and provide data as it is generated. Unbounded streams must be continuously processed, i.e., events must be promptly handled after they have been ingested. It is not possible to wait for all input data to arrive because the input is unbounded and will not be complete at any point in time. Processing unbounded data often requires that events are ingested in a specific order, such as the order in which events occurred, to be able to reason about result completeness.","title":"Unbounded streams"},{"location":"streams/#bounded-streams","text":"Bounded streams can be processed by ingesting all data before performing any computations. Ordered ingestion is not required to process bounded streams because a bounded data set can always be sorted. Processing of bounded streams is also known as batch processing.","title":"Bounded streams"},{"location":"streams/#ksqldb","text":"create stream orders_stream (orderId int, product VARCHAR) WITH (KAFKA_TOPIC='streaming.orders.input', VALUE_FORMAT='JSON'); select * from orders_stream emit changes; SET 'auto.offset.reset'='earliest';","title":"ksqlDB"},{"location":"angular/angular-material/","text":"Angular Material Installing Angular Material dependencies npm install @angular/material @angular/cdk @angular/animations hammerjs Adding Google Material Icons Font Add this to our index.html: <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"> Choosing a Theme inside node_modules/@angular/material/prebuild-themes We can for example use the Indigo Pink theme by adding this line to our styles.css file: @import \"~@angular/material/prebuilt-themes/indigo-pink.css\";","title":"Angular Material"},{"location":"angular/angular-material/#angular-material","text":"","title":"Angular Material"},{"location":"angular/angular-material/#installing-angular-material-dependencies","text":"npm install @angular/material @angular/cdk @angular/animations hammerjs","title":"Installing Angular Material dependencies"},{"location":"angular/angular-material/#adding-google-material-icons-font","text":"Add this to our index.html: <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\">","title":"Adding Google Material Icons Font"},{"location":"angular/angular-material/#choosing-a-theme","text":"inside node_modules/@angular/material/prebuild-themes We can for example use the Indigo Pink theme by adding this line to our styles.css file: @import \"~@angular/material/prebuilt-themes/indigo-pink.css\";","title":"Choosing a Theme"},{"location":"angular/learning-angular/","text":"Learning Angular Displaying data from the component Interpolation <span>{{ title }}</span> Property Binding <span [innerText]=\"title\"></span> Notice that we bind to the Document Object Model (DOM) property of an element, not an HTML attribute, as it looks at first sight. The property inside square brackets is called the target property and is the property of the DOM element into which we want to bind. The variable on the right is called the template expression and corresponds to the public title property of the component. If the property is not public, the template will not be able to use it. To better understand how the Angular templating mechanism works, we need to first understand how Angular interacts with attributes and properties. It defines attributes in HTML to initialize a DOM property, and then it uses data binding to interact with the property directly Applying styles to the template The Angular framework provides two types of property binding to set both of them dynamically, class binding and style binding . We can apply a single class to an HTML element using the following syntax. <p [class.star]=\"isLiked\"></p> The star class will be added to the paragraph element when the isLiked expression is true. Otherwise, it will be removed from the element. If we want to apply multiple classes simultaneously, we can use the following syntax: <p [class]=\"currentClasses\"></p> Getting data from the template (event binding) An event binding listens for DOM events that occur on the target HTML element and responds to those events by calling corresponding methods in the component. <button (click)=\"onClick()\">Click me</button> It supports native DOM events that can be found at https://developer.mozilla.org/en-US/docs/Web/Events . The variable on the right is called the template statement and corresponds to the onClick public method of the component. Component methods must be public for the template to be able to call them. Communicating with other components Angular components expose a public API that allows them to communicate with other components. This API encompasses input properties , which we use to feed the component with data. It also exposes output properties we can bind event listeners to, thereby getting timely information about changes in the state of the component. Directives There are three types of directives: Components are directives with an associated template. Structural directives add or remove elements from the DOM. Attribute directives modify the appearance or define a custom behavior of a DOM element. Transforming elements using directives The Angular framework includes a set of ready-made structural directives that we can start using straight away: ngIf adds or removes a portion of the DOM tree based on an expression. ngFor iterates through a list of items and binds each item to a template. ngSwitch switches between templates within a specific set and displays each one depending on a condition Structure an Angular App How to create an Angular application that is correctly structured to enforce separation of concerns using modules and services An Angular module is a TypeScript class marked with the @NgModule decorator, which defines the following properties: declarations : The components, directives, and pipes that are registered with the module. imports : Other modules that contain declarations to be used by this module. The Angular CLI defines CommonModule automatically for us in this property. It is a module that is always used in Angular applications because it contains all the built-in directives and pipes that we usually would like to use. exports : Angular artifacts that are defined in declarations and are available for other modules to use. This is the public API of the module. It defines what is publicly accessible or not. Everything else that's not explicitly exported would be considered private or internal to the module. providers : Services that are provided from the module and are accessible from any module of the application. We'll learn more about providers in the How dependency injection works in Angular section. bootstrap : The main component of the application that will be rendered when the application starts up. This property is set only once in the main application module, AppModule, and is usually AppComponent. Typically, you should not change it unless there is a particular reason to do so.Important NoteThe main application module, AppModule, does not need to import CommonModule. Instead, it imports BrowserModule, which is used to run Angular applications in a browser platform that exports CommonModule by itself. When creating a new Angular application, the first step is to define the different features our application needs. We should keep in mind that each one should make sense on its own in isolation from the others. Once we've defined the set of features required, we will create a module for each one. Each module will then be filled with the components, directives, pipes, and services that shape the feature it represents. Always remember the principles of encapsulation and reusability when defining your feature set. The second step is to start creating components that will be used to visualize the features on the screen. Dependency Injection Angular components are responsible for the presentation logic and should not be concerned with how to get data, either from a static list or a remote endpoint. They only need to display it in the template. Thus, they delegate business logic to services to handle this type of task. An Angular service, by default, is not registered with a specific module like components, directives, and pipes are. Instead, it is registered with an injector \u2013 the root injector of the Angular application \u2013 as defined in the providedIn option import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } } Promises Promises introduce a new way of envisioning asynchronous data management by conforming to a neater and more solid interface. Different asynchronous operations can be chained at the same level and even be split and returned from other functions Limitations of Promises They cannot be canceled. They are immediately executed. They are one-time operations only; there is no easy way to retry them. They respond with only one value. Observables An observable is an object that maintains a list of dependents, called observers, and informs them about state and data changes by emitting events asynchronously. To do so, the observable implements all of the machinery that it needs to produce and emit such events. It can be fired and canceled any time, regardless of whether it has emitted the expected data already Observables return a stream of events, and our subscribers receive prompt notification of those events so that they can act accordingly. They do not perform an asynchronous operation and die (although we can configure them to do so), but start a stream of continuous events on which we can subscribe. That's not all, however. This stream can be a combination of many operations before they hit observers subscribed to it. Just as we can manipulate arrays with methods such as map or filter to transform them, we can do the same with the stream of events that are emitted by observables. This is known as reactive functional programming, and Angular makes the most of this paradigm to handle asynchronous information. Routing Modern and traditional web applications react differently when a URL changes inside the app. The architecture of each browser plays an essential part in this behavior. Older browsers initiate a new request to the server when the URL changes. Modern browsers, also known as HTML5 browsers, can change the URL and the history of the browser, when navigating in different views, without sending a request to the server using a technique called HTML5 pushState An Angular application must set the base HTML tag in the index.html file to enable pushState routing <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <title>MyApp</title> <base href=\"/\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"> </head> <body> <app-root></app-root> </body> </html> The href attribute informs the browser about the path it should follow when attempting to load external resources, such as media or CSS files, once it goes deeper into the URL hierarchy","title":"Learning Angular"},{"location":"angular/learning-angular/#learning-angular","text":"","title":"Learning Angular"},{"location":"angular/learning-angular/#displaying-data-from-the-component","text":"","title":"Displaying data from the component"},{"location":"angular/learning-angular/#interpolation","text":"<span>{{ title }}</span>","title":"Interpolation"},{"location":"angular/learning-angular/#property-binding","text":"<span [innerText]=\"title\"></span> Notice that we bind to the Document Object Model (DOM) property of an element, not an HTML attribute, as it looks at first sight. The property inside square brackets is called the target property and is the property of the DOM element into which we want to bind. The variable on the right is called the template expression and corresponds to the public title property of the component. If the property is not public, the template will not be able to use it. To better understand how the Angular templating mechanism works, we need to first understand how Angular interacts with attributes and properties. It defines attributes in HTML to initialize a DOM property, and then it uses data binding to interact with the property directly","title":"Property Binding"},{"location":"angular/learning-angular/#applying-styles-to-the-template","text":"The Angular framework provides two types of property binding to set both of them dynamically, class binding and style binding . We can apply a single class to an HTML element using the following syntax. <p [class.star]=\"isLiked\"></p> The star class will be added to the paragraph element when the isLiked expression is true. Otherwise, it will be removed from the element. If we want to apply multiple classes simultaneously, we can use the following syntax: <p [class]=\"currentClasses\"></p>","title":"Applying styles to the template"},{"location":"angular/learning-angular/#getting-data-from-the-template-event-binding","text":"An event binding listens for DOM events that occur on the target HTML element and responds to those events by calling corresponding methods in the component. <button (click)=\"onClick()\">Click me</button> It supports native DOM events that can be found at https://developer.mozilla.org/en-US/docs/Web/Events . The variable on the right is called the template statement and corresponds to the onClick public method of the component. Component methods must be public for the template to be able to call them.","title":"Getting data from the template (event binding)"},{"location":"angular/learning-angular/#communicating-with-other-components","text":"Angular components expose a public API that allows them to communicate with other components. This API encompasses input properties , which we use to feed the component with data. It also exposes output properties we can bind event listeners to, thereby getting timely information about changes in the state of the component.","title":"Communicating with other components"},{"location":"angular/learning-angular/#directives","text":"There are three types of directives: Components are directives with an associated template. Structural directives add or remove elements from the DOM. Attribute directives modify the appearance or define a custom behavior of a DOM element.","title":"Directives"},{"location":"angular/learning-angular/#transforming-elements-using-directives","text":"The Angular framework includes a set of ready-made structural directives that we can start using straight away: ngIf adds or removes a portion of the DOM tree based on an expression. ngFor iterates through a list of items and binds each item to a template. ngSwitch switches between templates within a specific set and displays each one depending on a condition","title":"Transforming elements using directives"},{"location":"angular/learning-angular/#structure-an-angular-app","text":"How to create an Angular application that is correctly structured to enforce separation of concerns using modules and services An Angular module is a TypeScript class marked with the @NgModule decorator, which defines the following properties: declarations : The components, directives, and pipes that are registered with the module. imports : Other modules that contain declarations to be used by this module. The Angular CLI defines CommonModule automatically for us in this property. It is a module that is always used in Angular applications because it contains all the built-in directives and pipes that we usually would like to use. exports : Angular artifacts that are defined in declarations and are available for other modules to use. This is the public API of the module. It defines what is publicly accessible or not. Everything else that's not explicitly exported would be considered private or internal to the module. providers : Services that are provided from the module and are accessible from any module of the application. We'll learn more about providers in the How dependency injection works in Angular section. bootstrap : The main component of the application that will be rendered when the application starts up. This property is set only once in the main application module, AppModule, and is usually AppComponent. Typically, you should not change it unless there is a particular reason to do so.Important NoteThe main application module, AppModule, does not need to import CommonModule. Instead, it imports BrowserModule, which is used to run Angular applications in a browser platform that exports CommonModule by itself. When creating a new Angular application, the first step is to define the different features our application needs. We should keep in mind that each one should make sense on its own in isolation from the others. Once we've defined the set of features required, we will create a module for each one. Each module will then be filled with the components, directives, pipes, and services that shape the feature it represents. Always remember the principles of encapsulation and reusability when defining your feature set. The second step is to start creating components that will be used to visualize the features on the screen.","title":"Structure an Angular App"},{"location":"angular/learning-angular/#dependency-injection","text":"Angular components are responsible for the presentation logic and should not be concerned with how to get data, either from a static list or a remote endpoint. They only need to display it in the template. Thus, they delegate business logic to services to handle this type of task. An Angular service, by default, is not registered with a specific module like components, directives, and pipes are. Instead, it is registered with an injector \u2013 the root injector of the Angular application \u2013 as defined in the providedIn option import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } }","title":"Dependency Injection"},{"location":"angular/learning-angular/#promises","text":"Promises introduce a new way of envisioning asynchronous data management by conforming to a neater and more solid interface. Different asynchronous operations can be chained at the same level and even be split and returned from other functions","title":"Promises"},{"location":"angular/learning-angular/#limitations-of-promises","text":"They cannot be canceled. They are immediately executed. They are one-time operations only; there is no easy way to retry them. They respond with only one value.","title":"Limitations of Promises"},{"location":"angular/learning-angular/#observables","text":"An observable is an object that maintains a list of dependents, called observers, and informs them about state and data changes by emitting events asynchronously. To do so, the observable implements all of the machinery that it needs to produce and emit such events. It can be fired and canceled any time, regardless of whether it has emitted the expected data already Observables return a stream of events, and our subscribers receive prompt notification of those events so that they can act accordingly. They do not perform an asynchronous operation and die (although we can configure them to do so), but start a stream of continuous events on which we can subscribe. That's not all, however. This stream can be a combination of many operations before they hit observers subscribed to it. Just as we can manipulate arrays with methods such as map or filter to transform them, we can do the same with the stream of events that are emitted by observables. This is known as reactive functional programming, and Angular makes the most of this paradigm to handle asynchronous information.","title":"Observables"},{"location":"angular/learning-angular/#routing","text":"Modern and traditional web applications react differently when a URL changes inside the app. The architecture of each browser plays an essential part in this behavior. Older browsers initiate a new request to the server when the URL changes. Modern browsers, also known as HTML5 browsers, can change the URL and the history of the browser, when navigating in different views, without sending a request to the server using a technique called HTML5 pushState An Angular application must set the base HTML tag in the index.html file to enable pushState routing <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <title>MyApp</title> <base href=\"/\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"> </head> <body> <app-root></app-root> </body> </html> The href attribute informs the browser about the path it should follow when attempting to load external resources, such as media or CSS files, once it goes deeper into the URL hierarchy","title":"Routing"}]}